name: Build and Push Docker Images

on:
  push:
    branches:
      - master
  pull_request:
    types:
      - closed
    branches:
      - master
  workflow_dispatch:
    inputs:
      image_name:
        description: 'Name of the image to build (leave empty to build all changed images)'
        required: false
        type: string
      force_build_all:
        description: 'Force build all images'
        required: false
        type: boolean
        default: false

jobs:
  detect-changes:
    if: github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.pull_request.merged == true) || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    outputs:
      changed-images: ${{ steps.changes.outputs.changed-images }}
      has-changes: ${{ steps.changes.outputs.has-changes }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect changed images
        id: changes
        run: |
          echo "Detecting changes in images directory..."
          
          # 处理手动触发的情况
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            if [ "${{ github.event.inputs.force_build_all }}" = "true" ]; then
              echo "Force building all images..."
              CHANGED_IMAGES=$(find images/ -maxdepth 1 -mindepth 1 -type d -exec basename {} \; 2>/dev/null || true)
            elif [ -n "${{ github.event.inputs.image_name }}" ]; then
              echo "Building specific image: ${{ github.event.inputs.image_name }}"
              CHANGED_IMAGES="${{ github.event.inputs.image_name }}"
            else
              echo "Manual trigger without specific image, detecting changes from last commit..."
              if git rev-parse HEAD~1 >/dev/null 2>&1; then
                CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD)
              else
                CHANGED_FILES=$(git ls-files)
              fi
              CHANGED_IMAGES=$(echo "$CHANGED_FILES" | grep "^images/" | cut -d'/' -f2 | sort | uniq || true)
              
              # 对于手动触发，也检查 image-requests.txt
              if [ -f "image-requests.txt" ]; then
                echo "Also reading image-requests.txt for manual trigger..."
                REQUESTED_IMAGES=$(grep -v "^#" image-requests.txt | grep -v "^$" | tr '\n' ' ' || true)
                if [ -n "$REQUESTED_IMAGES" ]; then
                  echo "Requested images from file: $REQUESTED_IMAGES"
                  if [ -n "$CHANGED_IMAGES" ]; then
                    CHANGED_IMAGES="$CHANGED_IMAGES $REQUESTED_IMAGES"
                  else
                    CHANGED_IMAGES="$REQUESTED_IMAGES"
                  fi
                fi
              fi
            fi
          else
            # 获取变更的文件列表
            if [ "${{ github.event_name }}" = "push" ]; then
              # 对于 push 事件，比较 HEAD 和前一个提交
              # 处理首次提交的情况
              if git rev-parse HEAD~1 >/dev/null 2>&1; then
                CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD)
              else
                # 首次提交，获取所有文件
                CHANGED_FILES=$(git ls-files)
              fi
            else
              # 对于 PR 合并事件，比较基础分支和合并的分支
              CHANGED_FILES=$(git diff --name-only ${{ github.event.pull_request.base.sha }} ${{ github.event.pull_request.head.sha }})
            fi
            
            echo "Changed files:"
            echo "$CHANGED_FILES"
            
            # 提取 images 目录下有变更的镜像目录
            CHANGED_IMAGES=$(echo "$CHANGED_FILES" | grep "^images/" | cut -d'/' -f2 | sort | uniq || true)
          fi
          
          echo "Changed images (one per line):"
          echo "$CHANGED_IMAGES"
          
          # 读取 image-requests.txt 文件中指定的镜像
          REQUESTED_IMAGES=""
          if [ -f "image-requests.txt" ]; then
            echo "Reading image-requests.txt..."
            # 读取文件，忽略空行和注释行
            REQUESTED_IMAGES=$(grep -v "^#" image-requests.txt | grep -v "^$" | tr '\n' ' ' || true)
            if [ -n "$REQUESTED_IMAGES" ]; then
              echo "Requested images from file: $REQUESTED_IMAGES"
              # 合并检测到的变更和请求的镜像
              if [ -n "$CHANGED_IMAGES" ]; then
                CHANGED_IMAGES="$CHANGED_IMAGES $REQUESTED_IMAGES"
              else
                CHANGED_IMAGES="$REQUESTED_IMAGES"
              fi
              echo "Combined images: $CHANGED_IMAGES"
            else
              echo "image-requests.txt exists but contains no valid entries"
            fi
          else
            echo "image-requests.txt not found, using only detected changes"
          fi
          
          # 动态过滤：只保留实际存在且有效的镜像目录
          if [ -n "$CHANGED_IMAGES" ]; then
            echo "Validating detected images..."
            FILTERED_IMAGES=""
            TOTAL_DETECTED=0
            VALID_COUNT=0
            
            # 去重处理
            UNIQUE_IMAGES=$(echo "$CHANGED_IMAGES" | tr ' ' '\n' | sort | uniq)
            
            for img in $UNIQUE_IMAGES; do
              TOTAL_DETECTED=$((TOTAL_DETECTED + 1))
              echo "  Checking image: $img"
              
              # 检查镜像目录是否实际存在
              if [ ! -d "images/$img" ]; then
                echo "    ❌ Directory not found: images/$img"
                continue
              fi
              
              # 检查是否有Dockerfile
              if [ ! -f "images/$img/Dockerfile" ]; then
                echo "    ❌ Dockerfile not found: images/$img/Dockerfile"
                continue
              fi
              
              echo "    ✅ Valid image: $img"
              VALID_COUNT=$((VALID_COUNT + 1))
              
              if [ -n "$FILTERED_IMAGES" ]; then
                FILTERED_IMAGES="$FILTERED_IMAGES\n$img"
              else
                FILTERED_IMAGES="$img"
              fi
            done
            
            echo "Validation summary: $VALID_COUNT/$TOTAL_DETECTED images are valid"
            CHANGED_IMAGES="$FILTERED_IMAGES"
          fi
          
          echo "Final valid images (one per line):"
          echo -e "$CHANGED_IMAGES"
          
          if [ -n "$CHANGED_IMAGES" ] && [ "$CHANGED_IMAGES" != "" ]; then
            # 转换为一行 JSON 数组格式，供 matrix 使用
            IMAGES_JSON=$(echo -e "$CHANGED_IMAGES" | jq -R -s 'split("\n") | map(select(length > 0))' | jq -c)
            echo "changed-images=$IMAGES_JSON" >> $GITHUB_OUTPUT
            echo "has-changes=true" >> $GITHUB_OUTPUT
            echo "Generated JSON for matrix: $IMAGES_JSON"
          else
            echo "changed-images=[]" >> $GITHUB_OUTPUT
            echo "has-changes=false" >> $GITHUB_OUTPUT
          fi

  build-images:
    needs: detect-changes
    if: needs.detect-changes.outputs.has-changes == 'true'
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        image: ${{ fromJson(needs.detect-changes.outputs.changed-images) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_TOKEN }}

      - name: Generate image tag
        id: tag
        run: |
          # 使用 Git commit SHA 的前8位作为标签，更稳定且有意义
          TAG=$(echo "${{ github.sha }}" | cut -c1-8)
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "Generated tag: $TAG"

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./images/${{ matrix.image }}
          file: ./images/${{ matrix.image }}/Dockerfile
          push: true
          tags: |
            ${{ secrets.DOCKER_HUB_USERNAME }}/${{ matrix.image }}:${{ steps.tag.outputs.tag }}
            ${{ secrets.DOCKER_HUB_USERNAME }}/${{ matrix.image }}:latest
            ${{ secrets.DOCKER_HUB_USERNAME }}/${{ matrix.image }}:${{ github.ref_name }}
          platforms: linux/amd64,linux/arm64
          cache-from: type=gha
          cache-to: type=gha,mode=max
          labels: |
            org.opencontainers.image.title=${{ matrix.image }}
            org.opencontainers.image.description=Docker image for ${{ matrix.image }}
            org.opencontainers.image.url=https://github.com/${{ github.repository }}
            org.opencontainers.image.source=https://github.com/${{ github.repository }}
            org.opencontainers.image.version=${{ steps.tag.outputs.tag }}
            org.opencontainers.image.created=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
            org.opencontainers.image.revision=${{ github.sha }}

      - name: Update README with new tag
        run: |
          echo "## Built Images" >> build-summary.md
          echo "- **${{ matrix.image }}**: \`${{ secrets.DOCKER_HUB_USERNAME }}/${{ matrix.image }}:${{ steps.tag.outputs.tag }}\`" >> build-summary.md
          echo "- **${{ matrix.image }}** (latest): \`${{ secrets.DOCKER_HUB_USERNAME }}/${{ matrix.image }}:latest\`" >> build-summary.md
          echo "- **Build time**: $(date -u)" >> build-summary.md
          echo "- **Commit**: ${{ github.sha }}" >> build-summary.md

      - name: Upload build summary
        uses: actions/upload-artifact@v4
        with:
          name: build-summary-${{ matrix.image }}
          path: build-summary.md

  notify:
    needs: [detect-changes, build-images]
    if: always() && needs.detect-changes.outputs.has-changes == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Download build summaries
        uses: actions/download-artifact@v4
        with:
          pattern: build-summary-*
          path: summaries
          merge-multiple: true

      - name: Create notification
        run: |
          echo "Docker images have been built and pushed successfully!"
          echo "Changed images: ${{ needs.detect-changes.outputs.changed-images }}"
          
          if [ -d "summaries" ]; then
            echo "Build summaries:"
            find summaries -name "*.md" -exec cat {} \;
          fi